use super::*;

// note we are working Big-Endian
const MSB: [u8; 16] = [
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

const LSB: [u8; 16] = [
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
];

const TWO: [u8; 16] = [
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
];

const POLY: [u8; 16] = [
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87,
];

#[test]
fn test_parse() {
    let parsed = parse_input(&MSB);
    assert_eq!(parsed, (1 << 63, 0));
    let parsed = parse_input(&LSB);
    assert_eq!(parsed, (0, 1));
}

#[test]
fn sanity_checks() {
    assert_eq!(gfmul(&LSB, &LSB), LSB);
    assert_eq!(gfmul(&LSB, &TWO), TWO);
    assert_eq!(gfmul(&MSB, &LSB), MSB);
}

#[test]
fn overflow_checks() {
    assert_eq!(gfmul(&MSB, &TWO), POLY);
}

// #[test]
// fn test_ghash_mul_complex() {
//     let x = [
//         0xaa, 0xe0, 0x69, 0x92, 0xac, 0xbf, 0x52, 0xa3, 0xe8, 0xf4, 0xa9, 0x6e, 0xc9, 0x30, 0x0b,
//         0xd7,
//     ];
//     let y = [
//         0x98, 0xe7, 0x24, 0x7c, 0x07, 0xf0, 0xfe, 0x41, 0x1c, 0x26, 0x7e, 0x43, 0x84, 0xb0, 0xf6,
//         0x00,
//     ];
//     let expected = [
//         0x90, 0xe8, 0x73, 0x15, 0xfb, 0x7d, 0x4e, 0x1b, 0x40, 0x92, 0xec, 0x0c, 0xbf, 0xda, 0x5d,
//         0x7d,
//     ];
// assert_eq!(gfmul(&x, &y), expected);
// }

// #[test]
// fn test_block_right_shift() {
//     let input = [
//         0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00,
//     ];
//     let expected = [
//         0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00,
//     ];
//     let (output, msb) = block_right_shift(&input);

//     assert_eq!(output, expected);
//     assert_eq!(msb, 0);
// }

// #[test]
// fn test_block_right_shift_msb() {
//     let input = [
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x01,
//     ];
//     let expected = [
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00,
//     ];
//     let (output, msb) = block_right_shift(&input);

//     assert_eq!(output, expected);
//     assert_eq!(msb, 1);
// }

// #[test]
// fn test_mulx() {
//     let input = [
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x01,
//     ];
//     let expected = [
//         0xE1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00,
//     ];

//     assert_eq!(mulx(&input), expected);
// }

// #[test]
// fn test_z_update_no_change() {
//     let z = [
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00,
//     ];
//     let v = [
//         0xE1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x01,
//     ];
//     let bit_val = 0;
//     let expected = [
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00,
//     ];

//     assert_eq!(z_update(&z, &v, bit_val), expected);
// }

// #[test]
// fn test_z_update_with_change() {
//     let z = [
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00,
//     ];
//     let v = [
//         0xE1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x01,
//     ];
//     let bit_val = 1;
//     let expected = [
//         0xE1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x01,
//     ];

//     assert_eq!(z_update(&z, &v, bit_val), expected);
// }
